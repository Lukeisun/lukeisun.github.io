---
title: "Starting 'got' - A git clone in Go"
description: "Documenting my experience following along in James Coglan's book 'Building Git"
pubDate: "Sep 20, 2023"
heroImage: "/got.png" 
---
Over the past few weeks I have had a lingering urge to build something. Usually whenever I get this feeling
I get in a state of trying to find something to do, and then not doing anything. After hearing advice to 
build tools like `ls`, `cat`, or other GNU utils; I stumbled upon James Coglan's [Building Git](https://shop.jcoglan.com/building-git/)
and thought that it was exciting! So I bought it and have been spending some of my spare time working on it; I have been stalling on it 
as I'm working on daily driving Linux so that has been taking my time. I also wanted to get more familiar with Go, so why not combine the two.

The part that has piqued my interest most in this process is learning about compression and some of the standards, those standards being [zlib](https://datatracker.ietf.org/doc/html/rfc1950), 
[DEFLATE](https://datatracker.ietf.org/doc/html/rfc1951), and [gzip](https://datatracker.ietf.org/doc/html/rfc1952). The curiosty came from when I was following along
in the book, and was examining the anatomy of `.git`. At this point in the book, James was demonstrating generating the SHA value of a compressed blob for use as an 
ID in `.git/objects`. But I got confused as the SHA value I was getting from the compressed blob was completely differnt from his. My immediate thought was that I had 
messed up something in my Go code. Not seeing any glaring issues in my code, I launched a Python terminal and followed along there. I ended up getting the same exact value that
James got in his example. This caused me to go on a hours long search as to why. As it turns out, the actual bytes generated by the compression algorithm can be completely different
based on the *implementation*. The book is in Ruby and the reason why I got the same SHA1 hash in Python is that they both rely on the C bindings, and Go has implemented its own. Question answered!

I have not gotten very far in the book but looking forward to learning more :). 

Here is my very messy code so far. I noticed that in the book there are some bits that have been abstracted already but I'll do that as I see necessary, mostly because 
I want to keep it simple, even if it is stupid. 
```go
package main

import (
	"bytes"
	"compress/flate"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"io/fs"
	"log"
	"os"
	"path"
	"path/filepath"
)

func main() {
	command := os.Args[1]
	switch command {
	case "init":
		Init()
	case "commit":
		Commit()
	default:
		log.Fatal("Unknown command")
	}
}
func Commit() {
	root, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	git_path := path.Join(root, ".git")
	// objects_path := path.Join(git_path, "objects")
	// workspace in book
	workspace_path := "."
	ignore_arr := []string{".git", ".", ".."}
	ignore := make(map[string]struct{})
	for _, s := range ignore_arr {
		ignore[s] = struct{}{}
	}
	var arr []string
	filepath.WalkDir(workspace_path, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			log.Fatal(err)
		}
		if d.IsDir() && d.Name() == ".git" {
			return filepath.SkipDir
		}
		if _, ok := ignore[d.Name()]; ok {
			return nil
		}
		arr = append(arr, path)
		return nil
	})
	// database in book
	database_path := path.Join(git_path, "objects")
	filesystem := os.DirFS(workspace_path)
	for _, s := range arr {
		file, _ := fs.ReadFile(filesystem, s)
		// make blob
		byte_len := fmt.Sprintf("%d", len(file))
		content := "blob " + byte_len + "\x00" + string(file)
		oid := get_sha_str(content)
		// create dir and file
		dir := path.Join(database_path, oid[:2])
		err := os.Mkdir(dir, fs.ModePerm)
		if err != nil {
			if os.IsExist(err) {
				continue
			} else {
				log.Fatal(err)
			}
		}
		file_path := path.Join(dir, oid[2:])
		f, err := os.Create(file_path)
		if err != nil {
			log.Fatal(err)
		}
		defer f.Close()
		compressed := deflate(content, flate.BestSpeed)
		f.Write(compressed)
	}
}

func deflate(str string, level int) []byte {
	var buf bytes.Buffer
	w, _ := flate.NewWriter(&buf, level)
	w.Write([]byte(str))
	w.Flush()

	return buf.Bytes()
}
func get_sha_str(str string) string {
	hasher := sha1.New()
	str_bytes := []byte(str)
	hasher.Write(str_bytes)
	hash := hasher.Sum(nil)
	return hex.EncodeToString(hash)
}
func Init() {
	root, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	git_path := path.Join(root, ".git")
	err = os.Mkdir(git_path, fs.ModePerm)
	if err != nil {
		if os.IsExist(err) {
			fmt.Println(".git already exists, checking for subfolders")
		} else if os.IsPermission(err) {
			log.Fatal(git_path + "Permission denied")
		} else {
			log.Fatal(err)
		}
	}
	folderNames := []string{"objects", "refs"}
	for _, folderName := range folderNames {
		folderPath := path.Join(git_path, folderName)
		if err != nil {
			fmt.Println("Folder " + folderName + " already exists")
		}
		os.Mkdir(folderPath, fs.ModePerm)
	}
	fmt.Println("Initialized empty got repository in " + git_path)
}
```


